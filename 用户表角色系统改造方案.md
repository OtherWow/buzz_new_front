# 用户表角色系统改造方案

## 现状分析

### 当前用户表结构 (`BoBaseUsers`)
你的用户表已经包含了丰富的字段，包括：
- 基础信息：`username`, `email`, `password_hash`
- 个人信息：`first_name`, `last_name`, `phone_number`, `country`
- KYC信息：`kyc_status`, `kyc_document_type` 等
- 业务字段：`user_partner`, `partner_status` 等
- 状态管理：`is_active`, `is_deleted`

### 问题分析
当前表缺少标准的角色权限管理机制，业务角色通过 `user_partner` 字段简单区分，无法满足复杂的权限控制需求。

## 改造方案

### 方案一：最小改动方案（推荐）

#### 1. 保持现有用户表不变
- 不修改 `BoBaseUsers` 表结构
- 通过关联表实现角色系统
- 向后兼容现有业务逻辑

#### 2. 新增角色系统表

**新增的表结构：**
```sql
-- 角色表
bo_roles
-- 权限表  
bo_permissions
-- 角色权限关联表
bo_role_permissions
-- 用户角色关联表
bo_user_roles
-- 菜单表（可选）
bo_menus
```

#### 3. 用户角色映射策略
```python
# 现有业务角色映射到新角色系统
PARTNER_ROLE_MAPPING = {
    None: 'USER',           # 普通用户
    'admin': 'SUPER_ADMIN', # 超级管理员
    'manager': 'ADMIN',     # 管理员
    'operator': 'OPERATOR', # 操作员
    'partner': 'PARTNER',   # 合伙人（新角色）
}
```

### 方案二：完全重构方案

#### 1. 修改用户表结构
在 `BoBaseUsers` 表中添加：
```python
# 添加到 BoBaseUsers 类
default_role_id: Optional[int] = Field(default=4, description="默认角色ID")
current_role_id: Optional[int] = Field(default=None, description="当前使用角色ID")
```

#### 2. 废弃旧字段
- `user_partner` → 使用角色系统替代
- `partner_status` → 使用角色状态替代

## 推荐实施步骤

### 第一步：创建角色权限表
```sql
-- 执行 init_role_system.sql 脚本
-- 创建 bo_roles, bo_permissions, bo_role_permissions, bo_user_roles, bo_menus 表
```

### 第二步：数据迁移脚本
```sql
-- 为现有用户分配默认角色
INSERT INTO bo_user_roles (user_id, role_id, is_current)
SELECT 
    u.id,
    CASE 
        WHEN u.user_partner = 'admin' THEN 1      -- 超级管理员
        WHEN u.user_partner = 'manager' THEN 2   -- 管理员  
        WHEN u.user_partner = 'operator' THEN 3  -- 操作员
        ELSE 4                                    -- 普通用户
    END,
    1  -- 设为当前角色
FROM bo_base_users u 
WHERE u.is_deleted = 0 AND u.is_active = 1;
```

### 第三步：创建角色管理服务类
```python
class RoleService:
    @staticmethod
    async def get_user_roles(user_id: int) -> List[BoRole]:
        """获取用户的所有角色"""
        pass
    
    @staticmethod
    async def get_current_role(user_id: int) -> Optional[BoRole]:
        """获取用户当前角色"""
        pass
    
    @staticmethod
    async def switch_role(user_id: int, role_id: int) -> bool:
        """切换用户角色"""
        pass
    
    @staticmethod
    async def get_role_permissions(role_id: int) -> List[BoPermission]:
        """获取角色权限"""
        pass
    
    @staticmethod
    async def check_permission(user_id: int, permission_code: str) -> bool:
        """检查用户权限"""
        pass
```

## 业务场景适配

### 1. 交易系统角色设计

基于你的业务，建议以下角色层级：

```
超级管理员 (SUPER_ADMIN) - level 0
├── 系统管理员 (ADMIN) - level 1
├── 交易管理员 (TRADE_ADMIN) - level 2
├── 合伙人管理员 (PARTNER_ADMIN) - level 3
├── 操作员 (OPERATOR) - level 4
├── 合伙人 (PARTNER) - level 5
└── 普通用户 (USER) - level 6
```

### 2. 权限模块设计

```
用户管理模块 (user)
├── 查看用户 (USER_VIEW)
├── 创建用户 (USER_CREATE)
├── 编辑用户 (USER_EDIT)
└── 删除用户 (USER_DELETE)

交易管理模块 (transaction)
├── 查看交易 (TRANSACTION_VIEW)
├── 创建交易 (TRANSACTION_CREATE)
├── 编辑交易 (TRANSACTION_EDIT)
├── 删除交易 (TRANSACTION_DELETE)
└── 审核交易 (TRANSACTION_AUDIT)

交易所管理模块 (exchange)
├── 查看交易所 (EXCHANGE_VIEW)
├── 配置交易所 (EXCHANGE_CONFIG)
├── 管理API密钥 (EXCHANGE_API_MANAGE)
└── 监控交易所 (EXCHANGE_MONITOR)

合伙人管理模块 (partner)
├── 查看合伙人 (PARTNER_VIEW)
├── 审核合伙人 (PARTNER_AUDIT)
├── 管理返现 (PARTNER_CASHBACK)
└── 合伙人报告 (PARTNER_REPORT)
```

### 3. 与现有字段的兼容性

保持现有字段的业务逻辑：
- `partner_status` 继续用于合伙人业务状态
- `partner_exchange_id` 继续用于交易所绑定
- `user_partner` 可以作为角色的补充标识

## 实施建议

### 渐进式迁移
1. **第一阶段**：创建角色权限表，不修改现有表
2. **第二阶段**：为现有用户分配角色，双轨运行
3. **第三阶段**：逐步替换权限检查逻辑
4. **第四阶段**：完全切换到新权限系统

### 代码示例

#### 用户角色查询
```python
async def get_user_with_roles(user_id: int):
    # 查询用户基本信息
    user = await session.get(BoBaseUsers, user_id)
    
    # 查询用户角色
    user_roles = await session.exec(
        select(BoRole)
        .join(BoUserRole, BoRole.id == BoUserRole.role_id)
        .where(BoUserRole.user_id == user_id)
        .where(BoRole.is_active == 1)
    ).all()
    
    # 查询当前角色
    current_role = await session.exec(
        select(BoRole)
        .join(BoUserRole, BoRole.id == BoUserRole.role_id)
        .where(BoUserRole.user_id == user_id)
        .where(BoUserRole.is_current == 1)
    ).first()
    
    return {
        'user': user,
        'available_roles': user_roles,
        'current_role': current_role
    }
```

#### 权限检查
```python
async def check_user_permission(user_id: int, permission_code: str) -> bool:
    # 获取用户当前角色的权限
    result = await session.exec(
        select(BoPermission)
        .join(BoRolePermission, BoPermission.id == BoRolePermission.permission_id)
        .join(BoUserRole, BoRolePermission.role_id == BoUserRole.role_id)
        .where(BoUserRole.user_id == user_id)
        .where(BoUserRole.is_current == 1)
        .where(BoPermission.code == permission_code)
        .where(BoPermission.is_active == 1)
    ).first()
    
    return result is not None
```

## 优势

1. **灵活性**：支持用户多角色，动态角色切换
2. **扩展性**：权限可以细粒度控制，易于扩展
3. **兼容性**：不破坏现有业务逻辑
4. **标准化**：符合RBAC权限模型标准
5. **维护性**：权限集中管理，易于维护

这个方案既保持了你现有系统的稳定性，又为未来的权限管理提供了强大的扩展能力。你觉得这个改造方案怎么样？ 